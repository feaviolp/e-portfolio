<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
	This is an example of a sub page for each module.  It has to be replicated in each module, containing the requested contents -  artefacts, notes, reflections etc
	Ensure you give a different title to each replica and link it to the main module page accordingly.
-->
<html>
	<head>
		<title>Leigh Feaviour</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="/e-portfolio/css/main.css" />
		<noscript><link rel="stylesheet" href="/e-portfolio/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="/e-portfolio/index.html" class="logo"><span>Leigh Feaviour</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<<li><a href="/e-portfolio/index.html">Home</a></li>
							<li><a href="/e-portfolio/About.html">About Me</a></li>
							<li><a href="/e-portfolio/Launch Module.html">Induction Module</a></li>
							<li><a href="/e-portfolio/Module 2.html">Understanding Artificial Intelligence</a></li>
							<li><a href="/e-portfolio/Module 3.html">Numerical Analysis</a></li>
							<li><a href="/e-portfolio/Module 4.html">Machine Learning</a></li>
							<li><a href="/e-portfolio/Module 5.html">Knowledge Representation and Reasoning</a></li>
							<li><a href="/e-portfolio/Module 6.html">Intelligent Agents</a></li>
							<li><a href="/e-portfolio/Module 7.html">Research Methods and Professional Practice</a></li>
							<li><a href="/e-portfolio/Project.html">MSc Computing Project</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h1>Data Activities</h1>
									</header>

											<p><b><a id="Unit-1-Formative-Activities">Unit 1 Formative Activities</a></b>
                      									<p><b>Formative Activity 1.1</b>
											<br>Look at the seven topics described briefly below. Which of them would you consider yourself as ‘knowing’, and which would you consider yourself as having information about?
											<br>
											<br>&emsp;a. A second language in which you are fluent.
											<br>&emsp;b. The content of a television news programme.
											<br>&emsp;c. A close friend.
											<br>&emsp;d. A company’s annual report.
											<br>&emsp;e. Your close friend’s partner whom you have yet to meet.
											<br>&emsp;f. The weather on the other side of the world.
											<br>&emsp;g. The weather where you are now.
											<br><pre><code>I know, or have knowledge about:
	a. A second language in which you are fluent.
	c. A close friend.
	g. The weather where you are now.

I have inforamtion about:
	b. The content of a television news programme.
	d. A company’s annual report.
	e. Your close friend’s partner whom you have yet to meet.
	f. The weather on the other side of the world.</code></pre>


											<p><b>Formative Activity 1.2</b>
											<br>What would you suggest is the primary characteristic that distinguishes the ‘having information’ situations from the ‘knowing’ situations you categorised in the previous activity? You will need to make sure that your description does not simply describe information or data but must particularly take account of the former.
											<br><pre><code>Having information is knowing facts. Knowing, or having knowledge, 
is about having a more detailed and contextualised understanding so 
the facts can be interpreted to answer questions not immediately 
obvious from the facts alone.</code></pre></p>

											<p><b><a id="Unit-3-Formative-Activities">Unit 3 Formative Activities</a></b>
                      									<p><b>Formative Activity 3.1</b>
											<br>Attempt the following questions from the module core text:
											<br>
											<br><b>&emsp;- Chapter 2 Question 4 - The barber's paradox.</b>
											<br>In a certain town, there are the following regulations concerning the town barber:
											<ul><i>
												<li>Anyone who does not shave himself must be shaved by the barber.</li>
												<li>Whomever the barber shaves, must not shave himself.</li>
											</ul></i>
											Show that no barber can fulfil the requirements. That is, formulate the requirements as sentences of FOL and show that in any interpretation where the first regulation is true, the second one must be false. (This is called the <i>barber’s paradox</i> and was formulated by Bertrand Russell.)
											<br><pre><code>∃x∀y. Shaves(x,y) ∧ ¬Shaves(y,y)
There exists a barber (x) for all people (y) such that the barber (x) shaves the person (y), and 
the person (y) does not shave the person (y).

Where x ≠ y:
M⊨ Shaves(x,y) ∧ ¬Shaves(y,y)

Where x = y:
M ⊭ Shaves(x,x) ∧ ¬Shaves(x,x)</code></pre>
											<br> --- OR --- (better answer after looking for solutions using Google):
											<br><pre><code>Anyone who does not shave himself must be shaved by the barber:
∀x (¬Shave(x, x) → Shave(Barber, x))
												
Whomever the barber shaves, must not shave himself:
∀x (Shave(Barber, x) → ¬Shave(x, x))
												
If the barber shaves himself (Shave(Barber,Barber))) this contradicts the second sentence 
because the barber is shaving himself, so he must therefore not shave himself.
												
If the barber does not shave himself (¬Shave(Barber, Barber)) this contradicts the first
sentence, because the barber does not shave himself, so he must therefore shave himself.</code></pre>


											<br><b>&emsp;- Chapter 3 Question 4 - A Canadian variant of an old puzzle.</b>
											<br>A traveler in remote Quebec comes to a fork in the road and does not know which way to go to get to Chicoutimi. Henri and Pierre are two local inhabitants nearby who do know the way. One of them always tells the truth, and the other one never does, but the traveler does not know which is which. Is there a single question the traveler can ask Henri (in French, of course) that will be sure to tell him which way to go?</i>
											<br>
											<br>We will formalize this problem in FOL. Assume there are only two sorts of objects in our domain: inhabitants, denoted by the constants henri and pierre; and French questions, which Henri and Pierre can answer. These questions are denoted by the following terms:
											<ul>
												<li>gauche, which asks if the traveler should take the left branch of the fork to get to Chicoutimi;</li>
												<li>dit_oui(x, q), which asks if inhabitant x would answer yes to the French question q;</li>
												<li>dit_non(x, q), which asks if inhabitant x would answer no to the French question q.</li>
											</ul>
											Obviously this is a somewhat impoverished dialect of French, although a philosophically interesting one. For example, the term
											<br>
											<br>&emsp;dit_non(henri, dit_oui(pierre, gauche))
											<br>												
											<br>represents a French question that might be translated as, “Would Henri answer no if I asked him if Pierre would say yes I should go to the left to get to Chicoutimi?” The predicate symbols of our language are the following:
											<ul>
												<li>Truth_teller(x), which holds when inhabitant x is a truth teller;</li>
												<li>Answer_yes(x, q), which holds when inhabitant x will answer yes to French question q;</li>
												<li>True(q), which holds when the correct answer to the question q is yes;</li>
												<li>Go_left, which holds if the direction to get to Chicoutimi is to go left.</li>
											</ul>
											<br>For purposes of this puzzle, these are the only constant, function, and predicate symbols.
											<br>
											<br>(a) Write FOL sentences for each of the following:
											<br>
											<br>One of Henri or Pierre is a truth teller, and one is not.
											<br><pre><code>∃henri ∃pierre ((henri ≠ pierre) ∧ (Truth_teller(henri) ⊻ Truth_teller(pierre))</code></pre>
											<br>
											<br>An inhabitant will answer yes to a question if and only if he is a truth teller and the correct answer is yes, or he is not a truth teller and the correct answer is not yes.
											<br><pre><code>∀x ∀q (Answer_yes(x, q) ↔ ((Truth_teller(x) ∧ True(q)) ∨ (¬Truth_teller(x) ∧ ¬True(q))))
For all inhabitants and all questions, the inhabitant will answer yes to the question if and 
only if the inhabitant is the truth teller and the question is true, or the inhabitant is not
the truth teller and the question is not true.</code></pre>
											<br>The gauche question is correctly answered yes if and only if the proper direction is to go is left.
											<br><pre><code>True(gauche) ↔ Go_left</code></pre>
											<br>A dit_oui(x, q) question is correctly answered yes if and only if x will answer yes to question q.
											<br><pre><code>∀x ∀q (True(dit_oui(x, q)) ↔ Answer_yes(x, q))
For all inhabitants and all questions, the dit_oui answer will be true if and only if the answer is yes.</code></pre>
											<br>A dit_non(x, q) question is correctly answered yes if and only if x will not answer yes to q.
											<br><pre><code>∀x ∀q (True(dit_non(x, q)) ↔ ¬Answer_yes(x, q))
For all inhabitants and all questions, the dit_oui answer will be true if and only if the answer is not yes. </code></pre>
											<br>
											<br>Imagine that these facts make up the entire KB of the traveler.
											<br>(b) Show that there is a ground term <i>t</i> such that
											<br>
											<br>&emsp;KB ⊨ [Answer.yes(henri,<i>t</i>) ≡ Go.left].
											<br>
											<br>In other words, there is a question t that can be asked to Henri (and there is an analogous one for Pierre) that will be answered yes if and only if the proper direction to get to Chicoutimi is to go left.
											<br><pre><code>KB ⊨ [Answer.yes(henri.dit.non(pierre,gauche)) ≡ Go.left].

If Henri answers yes when asked if Pierre would say no to being asked if the correct 
direction is left, then the correct direction is left.</code></pre>
											<br>
											<br>(c) Show that this KB does not entail which direction to go, that is, show that there is an interpretation satisfying the KB where Go_left is true, and another one where it is false.
											<br><pre><code>If the correct direction is left and Henri is the truth teller:
∀x ∀q (Answer_yes(x, q) ↔ ((Truth_teller(x) ∧ True(q)) ∨ (¬Truth_teller(x) ∧ ¬True(q))))
Shows that Pierre (not the truth teller) will answer yes only when the answer is not true.
So Pierre would answer dit.non(pierre,gauche) as yes, because the correct answer is no.
But Henri would correctly say that Pierre would answer incorrectly, so:
Answer.yes(henri.dit.non(pierre,gauche))
is answered yes, resulting in the correct direction being left.

If the correct direction is left and Pierre is the truth teller:
∀x ∀q (Answer_yes(x, q) ↔ ((Truth_teller(x) ∧ True(q)) ∨ (¬Truth_teller(x) ∧ ¬True(q))))
Shows that Pierre (the truth teller) will answer yes only when the answer is true.
So Pierre would answer dit.non(pierre,gauche) as yes, because the correct answer is yes.
But Henri would incorrectly say that Pierre would answer incorrectly, so:
Answer.yes(henri.dit.non(pierre,gauche))
is answered yes, resulting in the correct direction being left.

If the correct direction is right and Henri is the truth teller:
∀x ∀q (Answer_yes(x, q) ↔ ((Truth_teller(x) ∧ True(q)) ∨ (¬Truth_teller(x) ∧ ¬True(q))))
Shows that Pierre (not the truth teller) will answer yes only when the answer is not true.
So Pierre would answer dit.non(pierre,gauche) as no, because the correct answer is yes.
But Henri would correctly say that Pierre would answer incorrectly, so:
Answer.yes(henri.dit.non(pierre,gauche))
is answered no, resulting in the correct direction being right.

If the correct direction is right and Pierre is the truth teller:
∀x ∀q (Answer_yes(x, q) ↔ ((Truth_teller(x) ∧ True(q)) ∨ (¬Truth_teller(x) ∧ ¬True(q))))
Shows that Pierre (the truth teller) will answer yes only when the answer is true.
So Pierre would answer dit.non(pierre,gauche) as yes, because the correct answer is yes.
But Henri would incorrectly say that Pierre would answer incorrectly, so:
Answer.yes(henri.dit.non(pierre,gauche))
is answered no, resulting in the correct direction being right.</code></pre>
                  
											<p><b>Formative Activity 3.2</b>
											<br>Read the paper by Palomino et al (2005) and review the ‘crossing problem’ diagram provided in the Lecturecast.
											<br>
											<br>Create a set of statements in first order logic (FOL) that represent the states shown – for example you may define two functions left and right and therefore the first state could be represented as: Left(F) and left(W) and Left(G) and left(C). Define your own set of FOL statements for the entire diagram.
											<br>You have been provided with solutions to the ‘crossing problem’ written in Lisp, Prolog and Maude. Compare your FOL clauses with the various implementations – which of the implementations provides the closest match to your FOL version?
											<br>The problem states: A farmer needs to transport to the other side of a river a wolf, a goat, and a cabbage. He has only a boat with room for the farmer himself and another item. The problem is that in the absence of the farmer the wolf would eat the goat, and the goat would eat the cabbage.
											<br><pre><code>Farmer = F
Wolf = W
Goat = G
Cabbage = C

<b>Safe states (in the sequence of the solution diagram)</b>
Left(F) ∧ Left(W) ∧ Left(G) ∧ Left(C)
Right(F) ∧ Left(W) ∧ Right(G) ∧ Left(C)
Left(F) ∧ Left(W) ∧ Right(G) ∧ Left(C)
Right(F) ∧ Left(W) ∧ Right(G) ∧ Right(C)
Left(F) ∧ Left(W) ∧ Left(G) ∧ Right(C)
Right(F) ∧ Right(W) ∧ Left(G) ∧ Right(C)
Left(F) ∧ Right(W) ∧ Left(G) ∧ Right(C)
Right(F) ∧ Right(W) ∧ Right(G) ∧ Right(C)
--- two additional safe states not in the diagram (can solve without them) ---
Left(F) ∧ Right(W) ∧ Left(G) ∧ Left(C)
Right(F) ∧ Right(W) ∧ Right(G) ∧ Left(C)

<b>Unsafe states</b>
Left(F) ∧ Right(W) ∧ Right(G) ∧ Left(C) – wolf eats goat
Right(F) ∧ Left(W) ∧ Left(G) ∧ Right(C) – wolf eats goat
Left(F) ∧ Left(W) ∧ Right(G) ∧ Right(C) – goat eats cabbage
Right(F) ∧ Right(W) ∧ Left(G) ∧ Left(C) – goat eats cabbage
Left(F) ∧ Right(W) ∧ Right(G) ∧ Right(C) – goat eats cabbage AND wolf eats goat
Right(F) ∧ Left(W) ∧ Left(G) ∧ Left(C) – goat eats cabbage AND wolf eats goat

None of the example code solutions look the same. The Prolog example seems to be
most similar because it defines unsafe states when the goat and cabbage are
together without the farmner, or the wolf and goat without the farmer, although
is uses a simpler notation simply saying which members should change sides without
needing to say from which side to which.</code></pre>

											<p><b><a id="Unit-5-Formative-Activities">Unit 5 Formative Activities</a></b>
											<p><b>Formative Activity 5.1</b>
											<br>Read the article by Bimba et al (2016) and then answer the following questions:
											<br>
											<br>&emsp;- What are the 3 knowledge bases identified by the authors?
											<br><pre><code>        1. Linguistic knowledge base.
        2. Expert Knowledge Base.
        3. Cognitive Knowledge Base.</code></pre>
											<br>&emsp;- What are the differences between them?
											<br><pre><code>Linguistic knowledge bases are lexical databases

Expert knowledge bases are represented as a set or rules.

Cognitive knowledge bases dynamically manipulate knowledge.</code></pre>
											<br>&emsp;- How are these related to ontologies?
											<br><pre><code>Ontologies model domains using classes, relationships and instances to enable sharing 
and re-use of the knowledge.

The three knowledge bases also enable sharing and re-use of knowedledge, so the 
similarities are clear. In fact the paper puts all four togther as "knowledge 
modelling approaches".</code></pre>

      									                <p><b>Formative Activity 5.2</b>
											<br>Read the article by Leydesdorff, L. (2010) and then answer the questions below:
											<br>
											<br>&emsp;- How does the author define a ‘Knowledge based economy’?
											<br><pre><code>The metaphor of a knowledge-based economy appreciates the increased importance of organized 
research and development (R&D) in shaping systems of innovation.</code></pre>
											<br>&emsp;- What is the triple helix model?
											<br><pre><code>The triple helix model of the knowledge-based economy has three subdynamics:
        1. Wealth generation
        2. Novelty production by science and technology
        3. Legislative control
											
The three 'helixes' continuously influence each other to drive the macro economy.</code></pre>

      									                <p><b>Formative Activity 5.3</b>
											<br>Read the Fensel et al (2000) paper then answer the following questions:
											<br>
											<br>&emsp;- What are the components of the On-To-Knowledge model/ framework?
											<br><pre><code>The components of the On-To-Knowledge framework are:
        - User Interface (to elicit the query to be answered)
        - QL engine (to convert the query into Resource Description Framework (RDF))
        - Data repository (Where the raw data is stored)
        - Annotated data respository (Where sematic annotations to the raw data are stored)
        - OIL (Ontology-based Inference Layer) ontology repository (provides the domain
          specific ontology for the queries and answers)</code></pre>
											<br>&emsp;- What are the example use cases given for the framework?
											<br><pre><code>Two use cases are given:
        1. Querying a skills description repository on the Swiss Life intranet.
        2. Locating the material that is required to answer a query at one of the 
           helpdesks operated by BT. /code></pre>

											<p><b><a id="Unit-6-Formative-Activity">Unit 6 Formative Activity</a></b>
											<br>Read Chapter 3 of Solanki, A (2019) An Introduction to Knowledge Engineering.
											<ul><i>
												<li>Reflect on the various data acquisition methods.</li>
												<li>What are the advantages and disadvantages of each method?</li>
												<li>Think about scenarios and which methods would be suitable for each.</li>
											</ul></i>
											<br><pre><code>The data aquisition methods described include:
<b><u>Unstructured interviews</b></u>
Used to gain an overall understanding of the knowledge domain.
Rarely provides a complete description, but useful to include areas that the interviewer
might not have even considered before due to their lack of knowledge.

<b><u>Structured interviews</b></u>
Used to obtain a greater depth of knowledge around in one ormore focused areas to understand
<i>why</i> in order to understand <i>how</i> for the expert system.

<b><u>Event recall interviews</b></u>
Good at revealing the decision making process by probing the rationale for key decisions
in a selected real life case study.

<b><u>Thinking aloud interviews</b></u>
Like event recall interviews, they seek to uncover <i>why</i> decisions are made. In this case the
expert explains their thinking in a given situation. The format is driven more by the expert than event
recall, so can be prone to going off-topic if not carefully managed.

<b><u>Tutorial interviews</b></u>
The expert gives a tutorial presentation of the subject. Like unstructured interviews, this is 
good for high-level early engagement, but not the final detailed analysis.

<b><u>Twenty questions interviews</b></u>
The interviewer asks closed questions to which the interviewee can only answer "yes" or "no".
The expert can be the interviewee to obtain basic concepts, or can be interviewer to test understanding,
so this technique can be used early or late in the knowledsge aquisition cycle.

<b><u>Trigger interviews</b></u>
Materials are issued to the expert during the interview to drigger memories and discussions.
Useful to test the quality of knowledge gathered to date.

<b><u>Teach back interviews</b></u>
The knowledge engineer "teaches" the expert to test understanding.
Like trigger interviews, this is useful to test the quality of knowledge gathered to date.

<b><u>Repertory grids</b></u>
This is a knowledge aquisition technique that sits alongside teh various interview techniques. 
A grid is produced with elements of the problem as columns and constructs as rows.
Intersects are then either selected (yes/no) to show relevence, or ranked if more appropriate.
The grid is then alanysed to identify similarities and differences between elements within the domain.</code></pre>

											<p><b><a id="Unit-8-Formative-Activity">Unit 8 Formative Activity</a></b>
											<ul><i>
												<li>Work through a practical example by following Chapters 3 - 4 of A Practical Guide to Building OWL Ontologies Using Protégé 4 and CO-ODE Tools.</li>
												<li>Create an ontology of pizza following the steps outlined in Exercises 2-6.</li>
											</ul></i>
											<br><pre><code>Answer here</code></pre>

											<p><b><a id="Unit-10-Formative-Activity">Unit 10 Formative Activity</a></b>
											<br>Read Chapter 6 - More on Open World Reasoning of Horridge, M. (2011) A Practical Guide To Building OWL Ontologies, Using Prot´eg´e 4 and CO-ODE Tools. Manchester: University of Manchester.
											<br>
											<br>Then work through a practical example by following Chapters 3 and 4 and create a NonVegetarianPizza using the steps outlined in Exercise 52.
											<br><pre><code>Answer here</code></pre>
                  
								</div>
							</section>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<div class="inner">
							<ul class="icons">
								<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
								<li><a href="https://www.linkedin.com/in/leigh-feaviour/" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
							</ul>
							<ul class="copyright">
								<li>&copy; 2022 Leigh Feaviour</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li>
							</ul>
						</div>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="/e-portfolio/js/jquery.min.js"></script>
			<script src="/e-portfolio/js/jquery.scrolly.min.js"></script>
			<script src="/e-portfolio/js/jquery.scrollex.min.js"></script>
			<script src="/e-portfolio/js/browser.min.js"></script>
			<script src="/e-portfolio/js/breakpoints.min.js"></script>
			<script src="/e-portfolio/js/util.js"></script>
			<script src="/e-portfolio/js/main.js"></script>

	</body>
</html>
